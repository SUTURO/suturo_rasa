import argparse
import json
import numpy
import itertools
import requests

try:
    from TTS.api import TTS
    import whisper
    #import sounddevice as sd
    #sd.default.samplerate = 16000
    haveSound = True
except ModuleNotFoundError:
    haveSound = False
    print("WARNING: One of TTS or openai-whisper not found. Make sure to sudo pip install these.\n    Will continue, but no tests involving sound generation or transcription will be performed.")
except ImportError:
    haveSound = False
    print("WARNING: could not import TTS. It is here, but may have dependencies with conflicting versions to what is installed.")

nluServer = "http://localhost:5005/model/parse"

testsFile = "tests.json"

def runTests(tests, speaker, transcriber, wavPath):
    def _differentStr(a,b):
        auxA = a.lower().strip()
        auxB = b.lower().strip()
        if auxA.endswith('.') or auxA.endswith('?'):
            auxA = auxA[:-1]
        if auxB.endswith('.') or auxB.endswith('?'):
            auxB = auxB[:-1]
        return auxA != auxB
    errors = []
    for t in tests:
        testText = t["text"]
        if (speaker is not None) and (transcriber is not None):
            wav = numpy.array(speaker.tts(testText, speaker=speaker.speakers[0], language=speaker.languages[0]),dtype=numpy.single)
            # make log-Mel spectrogram and move to the same device as the model
            mel = whisper.log_mel_spectrogram(wav).to(transcriber.device)
            options = {
                "fp16": False,
                "language": "en", # input language, if omitted is auto detected
                "task": "transcribe" # can also be translate but we do not need that here
            }
            testText = whisper.transcribe(transcriber, wav, **options).get("text", "").lower()
        r = requests.post(nluServer, data=bytes(json.dumps({"text": testText}), "utf-8"))
        response = json.loads(r.text)
        response = {"intent": response.get("intent",{}).get("name"), "entities": set([(x.get("entity"), x.get("role"), x.get("value")) for x in response.get("entities", []) if "DIETClassifier" == x.get("extractor")])}
        if (response != t["response"]) or _differentStr(testText, t["text"]):
            errs = []
            if _differentStr(testText, t["text"]):
                errs.append(testText.lower().strip())
            if response.get("intent") != t["response"].get("intent"):
                errs.append((t["response"].get("intent"), response.get("intent")))
            notInRes = []
            notInReq = []
            for e in t["response"].get("entities", []):
                if e not in response.get("entities", []):
                    notInRes.append(e)
            for e in response.get("entities", []):
                if e not in t["response"].get("entities", []):
                    notInReq.append(e)
            missmatch = {}
            for e in notInRes:
                if e[2] not in missmatch:
                    missmatch[e[2]] = []
                missmatch[e[2]].append(e)
            for e in notInReq:
                if e[2] not in missmatch:
                    continue
                missmatch[e[2]].append(e)
            missmatch = [x for x in missmatch.values() if 2 == len(x)]
            aux = list(itertools.chain.from_iterable(missmatch))
            notInRes = [x for x in notInRes if x not in aux]
            notInReq = [x for x in notInReq if x not in aux]
            if [] != missmatch:
                errs.append(("MISSMATCH", missmatch))
            if [] != notInRes:
                errs.append(("MISSING", notInRes))
            if [] != notInReq:
                errs.append(("INVENTED", notInReq))
            #if [] == errs:
            #   continue
            errors.append([t["text"], errs])
    return errors

def main():
    parser = argparse.ArgumentParser(prog='testing', description='Run the batch testing of NLU for the EASE HRI demo', epilog='Text at the end of help.')
    parser.add_argument('-i', '--inputFile', default="./tests.json", help='Path to input json file containing a list of tests generated by command_and_test_generator.')
    parser.add_argument('-s', '--testSound', default=False, action='store_true', help='Test sound to text by also generating readings of the test texts.')
    parser.add_argument('-w', '--wavPath', default="./wav.wav", help='Name of the wav file used during sound test. Must be a writable filename.')
    arguments = parser.parse_args()
    testsFile = arguments.inputFile
    testSound = arguments.testSound
    wavPath = arguments.wavPath
    tests = json.loads(open(testsFile).read())
    for t in tests:
        t["response"]["entities"] = set([tuple(x) for x in t["response"]["entities"]])
    speaker = None
    transcriber = None
    if haveSound and testSound:
        speaker = TTS(TTS.list_models()[0])
        transcriber = whisper.load_model("small.en")
    errors = runTests(tests, speaker, transcriber, wavPath)
    with open("errors.log", "w") as outfile:
        aux = []
        for e in errors:
            print(e)
            aux.append("\t[\"%s\",\n\t\t%s]" % (e[0], ',\n\t\t'.join([json.dumps(x) for x in e[1]])))
        _ = outfile.write('[\n%s\n]\n' % ',\n'.join(aux))

if "__main__" == __name__:
    main()

